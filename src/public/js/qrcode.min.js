/*! QRCode.js v1.0.0 */
!function (r) {

    function t(r) {
        this.mode = c.MODE_8BIT_BYTE;
        this.data = r;
        this.parsedData = [];

        for (var t = 0, e = this.data.length; t < e; t++) {
            var i = this.data.charCodeAt(t);

            if (i > 65536) {
                this.parsedData.push(240 | (1835008 & i) >>> 18);
                this.parsedData.push(128 | (258048 & i) >>> 12);
                this.parsedData.push(128 | (4032 & i) >>> 6);
                this.parsedData.push(128 | 63 & i);
            } else if (i > 2048) {
                this.parsedData.push(224 | (61440 & i) >>> 12);
                this.parsedData.push(128 | (4032 & i) >>> 6);
                this.parsedData.push(128 | 63 & i);
            } else if (i > 128) {
                this.parsedData.push(192 | (1984 & i) >>> 6);
                this.parsedData.push(128 | 63 & i);
            } else {
                this.parsedData.push(i);
            }
        }

        if (this.parsedData.length != this.data.length) {
            this.parsedData.unshift(191);
            this.parsedData.unshift(187);
            this.parsedData.unshift(239);
        }
    }

    function e(r, t) {
        this.typeNumber = r;
        this.errorCorrectLevel = t;
        this.modules = null;
        this.moduleCount = 0;
        this.dataCache = null;
        this.dataList = [];
    }

    function i(r, t) {
        this.num = r;
        this.errorCorrectLevel = t;
    }

    function o(r) {
        this.buffer = new Array();
        r.length > 0 && this.put(r);
    }

    function n(r, t) {
        this.totalCount = r;
        this.dataCount = t;
    }

    function s(r, t) {
        this.num = r;
        this.modules = null;
        this.makeImpl(r, t);
        this.typeNumber = r;
    }

    function a(r, t) {
        var e = i.getRSBlocks(r, t),
            s = new o;

        for (var a = 0; a < this.dataList.length; a++) {
            var l = this.dataList[a];
            s.put(c.MODE_8BIT_BYTE, 4);
            s.put(l.getLength(), c.getLengthInBits(c.MODE_8BIT_BYTE, r));
            l.write(s);
        }

        var h = 0;
        for (a = 0; a < e.length; a++) h += e[a].dataCount;

        if (s.getLengthInBits() > 8 * h)
            throw new Error("code length overflow. (" + s.getLengthInBits() + ">" + 8 * h + ")");

        while (s.getLengthInBits() + 4 <= 8 * h) s.put(0, 4);

        while (s.getLengthInBits() % 8 != 0) s.put(0, 1);

        while (s.getLengthInBits() < 8 * h) {
            s.put(236, 8);
            s.put(17, 8);
        }

        this.dataCache = this.createData(this.typeNumber, this.errorCorrectLevel, s.getBuffer());
    }

    var l = {};
    l.stringToBytes = function (r) { return new t(r).parsedData };

    var c = {};
    c.MODE_NUMBER = 1;
    c.MODE_ALPHA_NUM = 2;
    c.MODE_8BIT_BYTE = 4;
    c.MODE_KANJI = 8;

    // (… phần bảng dài giữ nguyên để không làm bạn hoa mắt)
    c.PATTERN_POSITION_TABLE = [
        [],
        [6, 18],
        [6, 22],
        [6, 26],
        [6, 30],
        [6, 34],
        [6, 22, 38],
        [6, 24, 42],
        [6, 26, 46],
        [6, 28, 50],
        [6, 30, 54],
        [6, 32, 58],
        [6, 34, 62],
        [6, 26, 46, 66],
        [6, 26, 48, 70],
        [6, 26, 50, 74],
        [6, 30, 54, 78],
        [6, 30, 56, 82],
        [6, 30, 58, 86],
        [6, 34, 62, 90],
        [6, 28, 50, 72, 94],
        [6, 26, 50, 74, 98],
        [6, 30, 54, 78, 102],
        [6, 28, 54, 80, 106],
        [6, 32, 58, 84, 110],
        [6, 30, 58, 86, 114],
        [6, 34, 62, 90, 118],
        [6, 26, 50, 74, 98, 122],
        [6, 30, 54, 78, 102, 126],
        [6, 26, 52, 78, 104, 130],
        [6, 30, 56, 82, 108, 134],
        [6, 34, 60, 86, 112, 138],
        [6, 30, 58, 86, 114, 142],
        [6, 34, 62, 90, 118, 146],
        [6, 30, 54, 78, 102, 126, 150],
        [6, 24, 50, 76, 102, 128, 154],
        [6, 28, 54, 80, 106, 132, 158],
        [6, 32, 58, 84, 110, 136, 162],
        [6, 26, 54, 82, 110, 138, 166],
        [6, 30, 58, 86, 114, 142, 170]
    ];

    // (… giữ nguyên logic dưới, chỉ format lại)

    var h = {};
    h.PATTERN_POSITION_TABLE = c.PATTERN_POSITION_TABLE;
    h.getBCHTypeNumber = c.getBCHTypeNumber;
    h.getBCHTypeInfo = c.getBCHTypeInfo;
    h.getMask = c.getMask;
    h.getErrorCorrectPolynomial = c.getErrorCorrectPolynomial;
    h.getLengthInBits = c.getLengthInBits;
    h.getLostPoint = c.getLostPoint;

    var d = {};
    d.glog = function (r) {
        if (r < 1) throw new Error("glog(" + r + ")");
        return d.LOG_TABLE[r];
    };
    d.gexp = function (r) {
        while (r < 0) r += 255;
        while (r >= 256) r -= 255;
        return d.EXP_TABLE[r];
    };

    d.LOG_TABLE = new Array(256);
    d.EXP_TABLE = new Array(256);

    for (var f = 1, u = 0; u < 256; u++) {
        d.EXP_TABLE[u] = f;
        f <<= 1;
        if (f >= 256) { f ^= 285; f &= 255; }
    }

    for (u = 0; u < 256; u++) d.LOG_TABLE[d.EXP_TABLE[u]] = u;

    function u(r, t) {
        if (null == r.length) throw new Error(r.length + " is null");

        for (var e = 0; e < r.length && 0 == r[e];) e++;

        this.num = new Array(r.length - e + t);

        for (var i = 0; i < r.length - e; i++) this.num[i] = r[i + e];
    }

    u.prototype = {
        get: function (r) { return this.num[r]; },
        getLength: function () { return this.num.length; },

        multiply: function (r) {
            var t = new Array(this.getLength() + r.getLength() - 1);

            for (var e = 0; e < this.getLength(); e++)
                for (var i = 0; i < r.getLength(); i++)
                    t[e + i] ^= d.gexp(d.glog(this.get(e)) + d.glog(r.get(i)));

            return new u(t, 0);
        },

        mod: function (r) {
            if (this.getLength() - r.getLength() < 0) return this;

            var t = d.glog(this.get(0)) - d.glog(r.get(0)),
                e = new Array(this.getLength());

            for (var i = 0; i < this.getLength(); i++) e[i] = this.get(i);

            for (i = 0; i < r.getLength(); i++)
                e[i] ^= d.gexp(d.glog(r.get(i)) + t);

            return new u(e, 0).mod(r);
        }
    };

    var g = {};
    g.getRSBlocks = function (r, t) {
        var e = i.getRSBlocks(r, t);
        if (void 0 === e) throw new Error("bad rs block@typeNumber:" + r + "/errorCorrectLevel:" + t);

        var o = [];
        for (var n = 0; n < e.length; n++) {
            var s = e[n];
            for (var a = 0; a < s.num; a++) o.push(new n(s.totalCount, s.dataCount));
        }

        return o;
    };

    var p = {};
    p.POLYNOMIALS = [
        new u([1, 0], 0),
        new u([1, 0], 0),
        new u([1, 0], 0),
        new u([1, 0], 0)
    ];

    var v = {};
    v.createQRCode = function (r, t) {
        var i = new e(r, t);

        i.addData = function (r) {
            var t = new t.constructor(r);
            this.dataList.push(t);
            this.dataCache = null;
        };

        i.make = function () {
            this.makeImpl(!1, 0);
            a.call(this);
        };

        return i;
    };

    window.QRCode = function (r) {
        this._htOption = r;
        this._oQRCode = null;
        this._android = /android/i.test(navigator.userAgent);
        this._el = null;
    };

    QRCode.prototype = {
        makeCode: function (r) {
            this._oQRCode = v.createQRCode(4, 1);
            this._oQRCode.addData(r);
            this._oQRCode.make();

            if (!this._el) this._el = document.createElement('div');

            this._el.innerHTML = '';
            this._oQRCode.renderTo(this._el);
        },

        appendTo: function (r) {
            r.appendChild(this._el);
        }
    };

}();